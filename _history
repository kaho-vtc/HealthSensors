{"entries":[{"timestamp":1739270074437,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  "],[0,"<blo"]],"start1":12,"start2":12,"length1":70,"length2":75},{"diffs":[[0,"ver\""],[-1," x=\"0\" y=\"0\""],[0,"></b"]],"start1":107,"start2":107,"length1":20,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"basic.forever(function () {\n\t\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":33,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".md\""],[-1,",\n        \"main.py\",\n        \"RemoteHealthSensors.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\""],[1,"\n    ],\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":215,"start2":215,"length1":98,"length2":44}]},{"type":"added","filename":"main.py","value":"def on_forever():\n    pass\nbasic.forever(on_forever)\n"},{"type":"added","filename":"RemoteHealthSensors.ts","value":"/**\n * Robot Arm Library_v1.02\n * Written by VTC STEM Education Centre\n * 16-09-2020\n */\n//% color=\"#03AA74\" icon=\"\\uf013\" blockGap=8 block=\"Robot Arm\"\nnamespace RobotArm \n{\n\n    //* Inverse Kinematics *//\n\n    // Global variable to init Robot Arm\n    declare var a1: number;\n    declare var a2: number;\n    declare var a3: number;\n\n    declare var s1: number;\n    declare var s2: number;\n    declare var s3: number;\n\n    declare var offSetS1: number;\n    declare var offSetS2: number;\n    declare var offSetS3: number;\n\n    declare var s3UpLimit: number;\n    declare var s3LowLimit: number;\n    declare var s2UpLimit: number;\n    declare var s2LowLimit: number;\n    declare var s1UpLimit: number;\n    declare var s1LowLimit: number;\n\n    declare var movement_delay: number;\n\n    offSetS1 = 0;\n    offSetS2 = 0;\n    offSetS3 = 0;\n\n    s3UpLimit = 180;\n    s3LowLimit = 0;\n    s2UpLimit = 180;\n    s2LowLimit = 0;\n    s1UpLimit = 180;\n    s1LowLimit = 0;\n\n    movement_delay = 50;\n\n    /**\n     * Initialize the length and offset of the robot arm\n     * @param _a1 [0-20] length of the robot arm; eg: 0\n     * @param _a2 [0-20] length of the robot arm; eg: 6\n     * @param _a3 [0-20] length of the robot arm; eg: 10\n    */\n    //% blockId=robotInit block=\"Set Length1 of a1: %_a1|Set Length1 of a2: %_a2|Set Length1 of a3: %_a3|Set Servo1: %servo1|Set Servo2: %servo2|Set Servo3: %servo3|Set Servo4: %servo4\"\n    //% weight=510\n    //% color=\"#E00064\"\n    //% _a1.min=0 _a1.max=20\n    //% _a2.min=0 _a2.max=20\n    //% _a3.min=0 _a3.max=20\n    //% _a1.defl=7\n    //% _a2.defl=11\n    //% _a3.defl=15\n    //% _servo1.defl=90\n    //% _servo2.defl=60\n    //% _servo3.defl=60\n    //% _servo4.defl=0\n    //% _servo1.shadow=\"protractorPicker\"\n    //% _servo2.shadow=\"protractorPicker\"\n    //% _servo3.shadow=\"protractorPicker\"\n    //% _servo4.shadow=\"protractorPicker\"\n    export function robotInitialize(_a1: number, _a2: number, _a3: number, _servo1: number, _servo2: number, _servo3: number, _servo4: number) {\n        a1 = _a1;\n        a2 = _a2;\n        a3 = _a3;\n        old_s1 = _servo1;\n        old_s2 = _servo2;\n        old_s3 = _servo3;\n        RobotArm.Servo(RobotArm.Servos.S1, old_s1)\n        basic.pause(1000)\n        RobotArm.Servo(RobotArm.Servos.S2, old_s2)\n        basic.pause(1000)\n        RobotArm.Servo(RobotArm.Servos.S3, old_s3)\n        basic.pause(1000)\n        RobotArm.Servo(RobotArm.Servos.S4, _servo4)\n        basic.pause(100)\n    }\n\n    /**\n     * Calulation of IK of robot arm\n     * @param x [0-15] length of the robot arm; eg: 6\n     * @param y [-15-15] length of the robot arm; eg: 0\n     * @param z [-10-15] length of the robot arm; eg: 5\n    */\n\n    //% block=\"Set Movement Delay(ms): %ms\"\n    //% weight=59\n    export function set_delay(ms: number) {\n        movement_delay = ms\n    }\n\n    //% blockId=robotIK block=\"Move To |x = %x| y = %y| z = %z\"\n    //% weight=60\n    //% x.min=0 x.max=15\n    //% y.min=-15 y.max=15\n    //% z.min=-10 z.max=15\n    // Calculating the variable joint parameters needed\n    // to place the end of a kinematic chain\n    export function ik(x: number, y: number, z: number): void {\n        let _r1: number = 0;\n        let _r2: number = 0;\n        let _r3: number = 0;\n        let _phi1: number = 0;\n        let _phi2: number = 0;\n        let _phi3: number = 0;\n        let _theta1: number = 0;\n        let _theta2: number = 0;\n        let _theta3: number = 0;\n\n        //The input x coordinate is postive number, force the number to negative for IK calculation\n        if (x > 0) {\n            x = x * (-1); //The x coordinate must be negative\n        } else if (x == 0) {\n            x = 0.001;\n        }\n\n        _r1 = Math.sqrt((x ** 2) + (y ** 2));\n        _r2 = z - a1;\n        _r3 = Math.sqrt((_r1 ** 2) + (_r2 ** 2));\n        _phi1 = Math.acos((a3 ** 2 - a2 ** 2 - _r3 ** 2) / (-2 * a2 * _r3)) * 180 / Math.PI;\n        _phi2 = Math.atan(_r2 / _r1) * 180 / Math.PI;\n        _phi3 = Math.acos((_r3 ** 2 - a2 ** 2 - a3 ** 2) / (-2 * a2 * a3)) * 180 / Math.PI;\n        _theta1 = Math.atan(y / x) * 180 / Math.PI;\n        _theta2 = (180 - _phi2) - _phi1;\n        _theta3 = 180 - _phi3;\n\n        s1 = Math.round(_theta1 + 90) + offSetS1;\n        s2 = Math.round(_theta2) + offSetS2;\n        s3 = Math.round(180 - _theta3) + offSetS3;\n\n        console.log(\"IK Servo s3 is:\");\n        console.log(s3);\n        console.log(\"IK Servo s2 is:\");\n        console.log(s2);\n        console.log(\"IK Servo s1 is:\");\n        console.log(s1);\n\n        RobotMotion(s1, s2, s3);\n\n    }\n    /**\n     * Initialize the length and offset of the robot arm\n     * @param _offSetS1 [-30-30] length of the robot arm; eg: 0\n     * @param _offSetS2 [-30-30] length of the robot arm; eg: 0\n     * @param _offSetS3 [-30-30] length of the robot arm; eg: 0\n    */\n\n    //% blockId=servoOffsetBlock block=\"Offset |S1 %_offSetS1| S2 %_offSetS2| S3 %_offSetS3\"\n    //% weight=504\n    //% color=\"#E00064\"\n\n    //% _offSetS1.min=-30 _offSetS1.max=30\n    //% _offSetS2.min=-30 _offSetS2.max=30\n    //% _offSetS3.min=-30 _offSetS3.max=30\n    export function servoOffSet(_offSetS1: number, _offSetS2: number, _offSetS3: number): void {\n\n        offSetS3 = _offSetS3;\n        offSetS2 = _offSetS2;\n        offSetS1 = _offSetS1;\n\n\n    }\n\n    /**\n     * Servo Limit of the robot arm\n     * @param _s1UpLimit [0-180] of the robot arm; eg: 180\n     * @param _s1LowLimit [0-180] of the robot arm; eg: 0\n     * @param _s2UpLimit [0-180] of the robot arm; eg: 180\n     * @param _s2LowLimit [0-180] of the robot arm; eg: 0\n     * @param _s3UpLimit [0-180] of the robot arm; eg: 180\n     * @param _s3LowLimit [0-180] of the robot arm; eg: 0\n    */\n\n    //% blockId=servoOffsetLimitBlock block=\"Servo Limit |S1: Upper $_s1UpLimit| Lower $_s1LowLimit|S2: Upper $_s2UpLimit| Lower $_s2LowLimit|S3: Upper $_s3UpLimit| Lower $_s3LowLimit\"\n    //% weight=503\n    //% color=\"#E00064\"\n    //% _s1UpLimit.shadow=\"protractorPicker\"\n    //% _s1LowLimit.shadow=\"protractorPicker\"\n    //% _s2UpLimit.shadow=\"protractorPicker\"\n    //% _s2LowLimit.shadow=\"protractorPicker\"\n    //% _s3UpLimit.shadow=\"protractorPicker\"\n    //% _s3LowLimit.shadow=\"protractorPicker\"\n\n    export function servoLimitOffSet(_s1UpLimit: number, _s1LowLimit: number,\n        _s2UpLimit: number, _s2LowLimit: number,\n        _s3UpLimit: number, _s3LowLimit: number): void {\n\n        s3UpLimit = _s3UpLimit + offSetS3;\n        s3LowLimit = _s3LowLimit + offSetS3;\n        s2UpLimit = _s2UpLimit + offSetS2;\n        s2LowLimit = _s2LowLimit + offSetS2;\n        s1UpLimit = _s1UpLimit + offSetS1;\n        s1LowLimit = _s1LowLimit + offSetS1;\n\n    }\n\n    //* Movement *//\n\n    declare var old_s1: number;\n    declare var old_s2: number;\n    declare var old_s3: number;\n\n    /**\n    * Control the movement of Robot Arm\n    */\n\n    function RobotMotion(_newS1: number, _newS2: number, _newS3: number): void {\n\n        let signS3: number;\n        let signS2: number;\n        let signS1: number;\n\n        if (_newS3 <= old_s3) {\n            signS3 = -1;\n        } else {\n            signS3 = 1;\n        }\n        if (_newS2 <= old_s2) {\n            signS2 = -1;\n        } else {\n            signS2 = 1;\n        }\n        if (_newS1 <= old_s1) {\n            signS1 = -1;\n        } else {\n            signS1 = 1;\n        }\n\n        if (_newS3 > s3UpLimit) {\n            _newS3 = s3UpLimit;\n            old_s3 = _newS3;\n\n        } else if (_newS3 < s3LowLimit) {\n            _newS3 = s3LowLimit;\n            old_s3 = _newS3;\n        }\n        if (_newS2 > s2UpLimit) {\n            _newS2 = s2UpLimit;\n            old_s2 = _newS2;\n\n        } else if (_newS2 < s2LowLimit) {\n            _newS2 = s2LowLimit;\n            old_s2 = _newS2;\n        }\n        if (_newS1 > s1UpLimit) {\n            _newS1 = s1UpLimit;\n            old_s1 = _newS1;\n\n        } else if (_newS1 < s1LowLimit) {\n            _newS1 = s1LowLimit;\n            old_s1 = _newS1;\n        }\n\n        while ((old_s3 != _newS3) || (old_s2 != _newS2) || (old_s1 != _newS1)) {\n            if (old_s3 != _newS3) {\n                RobotArm.Servo(RobotArm.Servos.S3, old_s3)\n                old_s3 = old_s3 + signS3;\n            }\n            if (old_s2 != _newS2) {\n                RobotArm.Servo(RobotArm.Servos.S2, old_s2)\n                old_s2 = old_s2 + signS2;\n            }\n            if (old_s1 != _newS1) {\n                RobotArm.Servo(RobotArm.Servos.S1, old_s1)\n                old_s1 = old_s1 + signS1;\n            }\n            basic.pause(movement_delay);\n\n            // console.log(\"Servo s3 is:\");\n            // console.log(old_s3);\n            // console.log(\"Servo s2 is:\");\n            // console.log(old_s2);\n            // console.log(\"Servo s1 is:\");\n            // console.log(old_s1);\n        }\n        //old_s1 = _newS1;\n        //old_s2 = _newS2;\n        //old_s3 = _newS3;\n    }\n\n    let _myNewS3: number = old_s3;\n    let _myNewS2: number = old_s2;\n    let _myNewS1: number = old_s1;\n    let _stepS3: number = 0;\n    let _stepS2: number = 0;\n    let _stepS1: number = 0;\n\n    /**\n    * Manual Control of Robot Arm\n    */\n    //% blockId=manualControl block=\"Set |S1 = %_mS1| S2 = %_mS2| S3 = %_mS3\"\n    //% weight=110\n    export function manualMotion(_mS1: number, _mS2: number, _mS3: number): void {\n\n        _myNewS3 = old_s3 + _mS3;\n        _myNewS2 = old_s2 + _mS2;\n        _myNewS1 = old_s1 + _mS1;\n\n        _stepS3 = _mS3 / 10;\n        _stepS2 = _mS2 / 10;\n        _stepS1 = _mS1 / 10;\n\n        if (_myNewS3 > s3UpLimit) {\n            _myNewS3 = s3UpLimit;\n            old_s3 = _myNewS3;\n\n        } else if (_myNewS3 < s3LowLimit) {\n            _myNewS3 = s3LowLimit;\n            old_s3 = _myNewS3;\n        }\n        if (_myNewS2 > s2UpLimit) {\n            _myNewS2 = s2UpLimit;\n            old_s2 = _myNewS2;\n\n        } else if (_myNewS2 < s2LowLimit) {\n            _myNewS2 = s2LowLimit;\n            old_s2 = _myNewS2;\n        }\n        if (_myNewS1 > s1UpLimit) {\n            _myNewS1 = s1UpLimit;\n            old_s1 = _myNewS1;\n\n        } else if (_myNewS1 < s1LowLimit) {\n            _myNewS1 = s1LowLimit;\n            old_s1 = _myNewS1;\n        }\n\n\n        while ((old_s3 != _myNewS3) || (old_s2 != _myNewS2) || (old_s1 != _myNewS1)) {\n            if (old_s3 != _myNewS3) {\n                RobotArm.Servo(RobotArm.Servos.S3, old_s3)\n\n                old_s3 = old_s3 + _stepS3;\n\n                console.log(\"Servo s3 is:\");\n                console.log(old_s3);\n\n            }\n            if (old_s2 != _myNewS2) {\n                RobotArm.Servo(RobotArm.Servos.S2, old_s2)\n                old_s2 = old_s2 + _stepS2;\n                console.log(\"Servo s2 is:\");\n                console.log(old_s2);\n            }\n            if (old_s1 != _myNewS1) {\n                RobotArm.Servo(RobotArm.Servos.S1, old_s1)\n                old_s1 = old_s1 + _stepS1;\n                console.log(\"Servo s1 is:\");\n                console.log(old_s1);\n            }\n            basic.pause(10);\n\n        }\n        //old_s1 = _newS1;\n        //old_s2 = _newS2;\n        //old_s3 = _newS3;\n    }\n\n\n    //* Servo Motor *//\n\n    const PCA9685_ADDRESS = 0x40\n    const MODE1 = 0x00\n    const PRESCALE = 0xFE\n    const LED0_ON_L = 0x06\n\n    export enum Servos {\n        S1 = 0x01,\n        S2 = 0x02,\n        S3 = 0x03,\n        S4 = 0x04,\n        S5 = 0x05,\n        S6 = 0x06,\n        S7 = 0x07,\n        S8 = 0x08\n    }\n\n    let initialized = false\n\n    function i2cwrite(addr: number, reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2cread(addr: number, reg: number) {\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\n        return val;\n    }\n\n    function initPCA9685(): void {\n        i2cwrite(PCA9685_ADDRESS, MODE1, 0x00)\n        setFreq(50);\n        for (let idx = 0; idx < 16; idx++) {\n            setPwm(idx, 0, 0);\n        }\n        initialized = true\n    }\n\n    function setFreq(freq: number): void {\n        // Constrain the frequency\n        let prescaleval = 25000000;\n        prescaleval /= 4096;\n        prescaleval /= freq;\n        prescaleval -= 1;\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\n        let oldmode = i2cread(PCA9685_ADDRESS, MODE1);\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\n        i2cwrite(PCA9685_ADDRESS, MODE1, newmode); // go to sleep\n        i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);\n        control.waitMicros(5000);\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);\n    }\n\n    function setPwm(channel: number, on: number, off: number): void {\n        if (channel < 0 || channel > 15)\n            return;\n\n        let buf = pins.createBuffer(5);\n        buf[0] = LED0_ON_L + 4 * channel;\n        buf[1] = on & 0xff;\n        buf[2] = (on >> 8) & 0xff;\n        buf[3] = off & 0xff;\n        buf[4] = (off >> 8) & 0xff;\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf);\n    }\n\n    /**\n     * Servo Execute\n     * @param index Servo Channel; eg: S1\n     * @param degree [0-180] degree of servo; eg: 0, 90, 180\n    */\n    //% blockId=robotbit_servo block=\"Servo|%index|degree %degree\"\n    //% weight=40\n    //% color=\"#00aeef\"\n    //% degree.min=0 degree.max=180\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function Servo(index: Servos, degree: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        // 50hz: 20,000 us\n        let v_us = (degree * 1800 / 180 + 600) // 0.6 ~ 2.4\n        let value = v_us * 4096 / 20000\n        setPwm(index + 7, 0, value)\n    }\n\n    /* Joystick */\n\n    export enum JoystickBitPin {\n        //% block=\"B1\"\n        P13 = DAL.MICROBIT_ID_IO_P13,\n        //% block=\"B2\"\n        P14 = DAL.MICROBIT_ID_IO_P14,\n        //% block=\"B3\"\n        P15 = DAL.MICROBIT_ID_IO_P15,\n        //% block=\"B4\"\n        P16 = DAL.MICROBIT_ID_IO_P16\n    }\n\n    export enum rockerType {\n        //% block=\"X\"\n        X,\n        //% block=\"Y\"\n        Y\n    }\n\n    export enum ButtonType {\n        //% block=\"pressed\"\n        down = PulseValue.High,\n        //% block=\"released\"\n        up = PulseValue.Low\n    }\n\n    /**\n    * initialization joystick\n    */\n    export function initJoystick(): void {\n        pins.digitalWritePin(DigitalPin.P12, 0)\n        pins.setPull(DigitalPin.P13, PinPullMode.PullUp)\n        pins.setPull(DigitalPin.P14, PinPullMode.PullUp)\n        pins.setPull(DigitalPin.P15, PinPullMode.PullUp)\n        pins.setPull(DigitalPin.P16, PinPullMode.PullUp)\n        //pins.digitalWritePin(DigitalPin.P0, 1)\n    }\n\n    //% block=\"Initialize Joystick\"\n    //% weight=500\n    //% color=\"#E00064\"\n    export function init_joystick() {\n        initJoystick()\n    }\n\n    /**\n    * get Button\n    */\n    //% blockId=getButton block=\"button %button is pressed\"\n    //% color=\"#FFAA00\"\n    //% weight=29\n    export function getButton(button: JoystickBitPin): boolean {\n        return (pins.digitalReadPin(<number>button) == 0 ? true : false)\n    }\n\n    /**\n    * Registers code to run when a joystick event is detected.\n    */\n    //% blockId=onButtonEvent block=\"on button %button|is %event\" blockExternalInputs=false\n    //% color=\"#FFAA00\"\n    //% weight=28\n    export function onButtonEvent(button: JoystickBitPin, event: ButtonType, handler: Action): void {\n        pins.onPulsed(<number>button, <number>event, handler);\n    }\n\n    /**\n    * get rocker value\n    * @param rocker describe parameter here, eg: 1\n    */\n    //% blockId=getRockerValue block=\"rocker value of %rocker\"\n    //% color=\"#FFAA00\"\n    //% weight=27\n    export function getRockerValue(rocker: rockerType): number {\n        switch (rocker) {\n            case rockerType.X: return pins.analogReadPin(AnalogPin.P2);\n            case rockerType.Y: return pins.analogReadPin(AnalogPin.P1);\n            default: return 0;\n        }\n    }\n\n    /**\n    * vibration motor\n    * @param time describe parameter here, eg: 100\n    */\n    //% blockId=Vibration_Motor block=\"motor vibrate for %time ms\"\n    //% color=\"#FFAA00\"\n    //% weight=26\n    export function Vibration_Motor(time: number): void {\n        pins.digitalWritePin(DigitalPin.P0, 0)\n        basic.pause(time)\n        pins.digitalWritePin(DigitalPin.P0, 1)\n    }\n\n}"}]},{"timestamp":1739270628286,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"352\" y=\"108\"><statement name=\"HANDLER\"><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"RemoteHealthSensors_read_temperature\"></block></value></block></statement"],[1,"0\" y=\"0\""],[0,"></b"]],"start1":106,"start2":106,"length1":250,"length2":16}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,") {\n"],[-1,"    basic.showNumber(RemoteHealthSensors.read_temperature())"],[1,"\t"],[0,"\n})\n"]],"start1":24,"start2":24,"length1":68,"length2":9}]},{"type":"edited","filename":"RemoteHealthSensors.ts","patch":[{"diffs":[[0,"/**\n * R"],[-1,"emoteHealthSensors"],[1,"obot Arm"],[0," Library"]],"start1":0,"start2":0,"length1":34,"length2":24},{"diffs":[[0,"ary_v1.0"],[1,"2"],[0,"\n * Writ"]],"start1":21,"start2":21,"length1":16,"length2":17},{"diffs":[[0," Centre\n"],[1," * 16-09-2020\n"],[0," */\n//% "]],"start1":63,"start2":63,"length1":16,"length2":30},{"diffs":[[0,"\"\\uf"],[-1,"1ec"],[1,"013"],[0,"\" block"],[-1,"=\"RemoteHealthSensors\"\nnamespace RemoteHealthSensors {\n    \n    //% block\n    export function read_temperature(): number \n    {\n        let temp_addr = 0x5A;\n        pins.i2cWriteNumber(temp_addr, 0x07, NumberFormat.UInt8LE, true);\n        let buff = pins.i2cReadBuffer(temp_addr, 3, true);\n        let result = buff[0] << 8;\n        result |= buff[1];\n        result *= 0.02"],[1,"Gap=8 block=\"Robot Arm\"\nnamespace RobotArm \n{\n\n    //* Inverse Kinematics *//\n\n    // Global variable to init Robot Arm\n    declare var a1: number;\n    declare var a2: number;\n    declare var a3: number;\n\n    declare var s1: number;\n    declare var s2: number;\n    declare var s3: number;\n\n    declare var offSetS1: number;\n    declare var offSetS2: number;\n    declare var offSetS3: number;\n\n    declare var s3UpLimit: number;\n    declare var s3LowLimit: number;\n    declare var s2UpLimit: number;\n    declare var s2LowLimit: number;\n    declare var s1UpLimit: number;\n    declare var s1LowLimit: number;\n\n    declare var movement_delay: number;\n\n    offSetS1 = 0;\n    offSetS2 = 0;\n    offSetS3 = 0;\n\n    s3UpLimit = 180;\n    s3LowLimit = 0;\n    s2UpLimit = 180;\n    s2LowLimit = 0;\n    s1UpLimit = 180;\n    s1LowLimit = 0;\n\n    movement_delay = 50;\n\n    /**\n     * Initialize the length and offset of the robot arm\n     * @param _a1 [0-20] length of the robot arm; eg: 0\n     * @param _a2 [0-20] length of the robot arm; eg: 6\n     * @param _a3 [0-20] length of the robot arm; eg: 10\n    */\n    //% blockId=robotInit block=\"Set Length1 of a1: %_a1|Set Length1 of a2: %_a2|Set Length1 of a3: %_a3|Set Servo1: %servo1|Set Servo2: %servo2|Set Servo3: %servo3|Set Servo4: %servo4\"\n    //% weight=510\n    //% color=\"#E00064\"\n    //% _a1.min=0 _a1.max=20\n    //% _a2.min=0 _a2.max=20\n    //% _a3.min=0 _a3.max=20\n    //% _a1.defl=7\n    //% _a2.defl=11\n    //% _a3.defl=15\n    //% _servo1.defl=90\n    //% _servo2.defl=60\n    //% _servo3.defl=60\n    //% _servo4.defl=0\n    //% _servo1.shadow=\"protractorPicker\"\n    //% _servo2.shadow=\"protractorPicker\"\n    //% _servo3.shadow=\"protractorPicker\"\n    //% _servo4.shadow=\"protractorPicker\"\n    export function robotInitialize(_a1: number, _a2: number, _a3: number, _servo1: number, _servo2: number, _servo3: number, _servo4: number) {\n        a1 = _a1;\n        a2 = _a2;\n        a3 = _a3;\n        old_s1 = _servo1;\n        old_s2 = _servo2;\n        old_s3 = _servo3;\n        RobotArm.Servo(RobotArm.Servos.S1, old_s1)\n        basic.pause(1000)\n        RobotArm.Servo(RobotArm.Servos.S2, old_s2)\n        basic.pause(1000)\n        RobotArm.Servo(RobotArm.Servos.S3, old_s3)\n        basic.pause(1000)\n        RobotArm.Servo(RobotArm.Servos.S4, _servo4)\n        basic.pause(100)\n    }\n\n    /**\n     * Calulation of IK of robot arm\n     * @param x [0-15] length of the robot arm; eg: 6\n     * @param y [-15-15] length of the robot arm; eg: 0\n     * @param z [-10-15] length of the robot arm; eg: 5\n    */\n\n    //% block=\"Set Movement Delay(ms): %ms\"\n    //% weight=59\n    export function set_delay(ms: number) {\n        movement_delay = ms\n    }\n\n    //% blockId=robotIK block=\"Move To |x = %x| y = %y| z = %z\"\n    //% weight=60\n    //% x.min=0 x.max=15\n    //% y.min=-15 y.max=15\n    //% z.min=-10 z.max=15\n    // Calculating the variable joint parameters needed\n    // to place the end of a kinematic chain\n    export function ik(x: number, y: number, z: number): void {\n        let _r1: number = 0;\n        let _r2: number = 0;\n        let _r3: number = 0;\n        let _phi1: number = 0;\n        let _phi2: number = 0;\n        let _phi3: number = 0;\n        let _theta1: number = 0;\n        let _theta2: number = 0;\n        let _theta3: number = 0;\n\n        //The input x coordinate is postive number, force the number to negative for IK calculation\n        if (x > 0) {\n            x = x * (-1); //The x coordinate must be negative\n        } else if (x == 0) {\n            x = 0.001;\n        }\n\n        _r1 = Math.sqrt((x ** 2) + (y ** 2));\n        _r2 = z - a1;\n        _r3 = Math.sqrt((_r1 ** 2) + (_r2 ** 2));\n        _phi1 = Math.acos((a3 ** 2 - a2 ** 2 - _r3 ** 2) / (-2 * a2 * _r3)) * 180 / Math.PI;\n        _phi2 = Math.atan(_r2 / _r1) * 180 / Math.PI;\n        _phi3 = Math.acos((_r3 ** 2 - a2 ** 2 - a3 ** 2) / (-2 * a2 * a3)) * 180 / Math.PI;\n        _theta1 = Math.atan(y / x) * 180 / Math.PI;\n        _theta2 = (180 - _phi2) - _phi1;\n        _theta3 = 180 - _phi3;\n\n        s1 = Math.round(_theta1 + 90) + offSetS1;\n        s2 = Math.round(_theta2) + offSetS2;\n        s3 = Math.round(180 - _theta3) + offSetS3;\n\n        console.log(\"IK Servo s3 is:\");\n        console.log(s3);\n        console.log(\"IK Servo s2 is:\");\n        console.log(s2);\n        console.log(\"IK Servo s1 is:\");\n        console.log(s1);\n\n        RobotMotion(s1, s2, s3);\n\n    }\n    /**\n     * Initialize the length and offset of the robot arm\n     * @param _offSetS1 [-30-30] length of the robot arm; eg: 0\n     * @param _offSetS2 [-30-30] length of the robot arm; eg: 0\n     * @param _offSetS3 [-30-30] length of the robot arm; eg: 0\n    */\n\n    //% blockId=servoOffsetBlock block=\"Offset |S1 %_offSetS1| S2 %_offSetS2| S3 %_offSetS3\"\n    //% weight=504\n    //% color=\"#E00064\"\n\n    //% _offSetS1.min=-30 _offSetS1.max=30\n    //% _offSetS2.min=-30 _offSetS2.max=30\n    //% _offSetS3.min=-30 _offSetS3.max=30\n    export function servoOffSet(_offSetS1: number, _offSetS2: number, _offSetS3: number): void {\n\n        offSetS3 = _offSetS3;\n        offSetS2 = _offSetS2;\n        offSetS1 = _offSetS1;\n\n\n    }\n\n    /**\n     * Servo Limit of the robot arm\n     * @param _s1UpLimit [0-180] of the robot arm; eg: 180\n     * @param _s1LowLimit [0-180] of the robot arm; eg: 0\n     * @param _s2UpLimit [0-180] of the robot arm; eg: 180\n     * @param _s2LowLimit [0-180] of the robot arm; eg: 0\n     * @param _s3UpLimit [0-180] of the robot arm; eg: 180\n     * @param _s3LowLimit [0-180] of the robot arm; eg: 0\n    */\n\n    //% blockId=servoOffsetLimitBlock block=\"Servo Limit |S1: Upper $_s1UpLimit| Lower $_s1LowLimit|S2: Upper $_s2UpLimit| Lower $_s2LowLimit|S3: Upper $_s3UpLimit| Lower $_s3LowLimit\"\n    //% weight=503\n    //% color=\"#E00064\"\n    //% _s1UpLimit.shadow=\"protractorPicker\"\n    //% _s1LowLimit.shadow=\"protractorPicker\"\n    //% _s2UpLimit.shadow=\"protractorPicker\"\n    //% _s2LowLimit.shadow=\"protractorPicker\"\n    //% _s3UpLimit.shadow=\"protractorPicker\"\n    //% _s3LowLimit.shadow=\"protractorPicker\"\n\n    export function servoLimitOffSet(_s1UpLimit: number, _s1LowLimit: number,\n        _s2UpLimit: number, _s2LowLimit: number,\n        _s3UpLimit: number, _s3LowLimit: number): void {\n\n        s3UpLimit = _s3UpLimit + offSetS3;\n        s3LowLimit = _s3LowLimit + offSetS3;\n        s2UpLimit = _s2UpLimit + offSetS2;\n        s2LowLimit = _s2LowLimit + offSetS2;\n        s1UpLimit = _s1UpLimit + offSetS1;\n        s1LowLimit = _s1LowLimit + offSetS1;\n\n    }\n\n    //* Movement *//\n\n    declare var old_s1: number;\n    declare var old_s2: number;\n    declare var old_s3: number;\n\n    /**\n    * Control the movement of Robot Arm\n    */\n\n    function RobotMotion(_newS1: number, _newS2: number, _newS3: number): void {\n\n        let signS3: number;\n        let signS2: number;\n        let signS1: number;\n\n        if (_newS3 <= old_s3) {\n            signS3 = -1;\n        } else {\n            signS3 = 1;\n        }\n        if (_newS2 <= old_s2) {\n            signS2 = -1;\n        } else {\n            signS2 = 1;\n        }\n        if (_newS1 <= old_s1) {\n            signS1 = -1;\n        } else {\n            signS1 = 1;\n        }\n\n        if (_newS3 > s3UpLimit) {\n            _newS3 = s3UpLimit;\n            old_s3 = _newS3;\n\n        } else if (_newS3 < s3LowLimit) {\n            _newS3 = s3LowLimit;\n            old_s3 = _newS3;\n        }\n        if (_newS2 > s2UpLimit) {\n            _newS2 = s2UpLimit;\n            old_s2 = _newS2;\n\n        } else if (_newS2 < s2LowLimit) {\n            _newS2 = s2LowLimit;\n            old_s2 = _newS2;\n        }\n        if (_newS1 > s1UpLimit) {\n            _newS1 = s1UpLimit;\n            old_s1 = _newS1;\n\n        } else if (_newS1 < s1LowLimit) {\n            _newS1 = s1LowLimit;\n            old_s1 = _newS1;\n        }\n\n        while ((old_s3 != _newS3) || (old_s2 != _newS2) || (old_s1 != _newS1)) {\n            if (old_s3 != _newS3) {\n                RobotArm.Servo(RobotArm.Servos.S3, old_s3)\n                old_s3 = old_s3 + signS3;\n            }\n            if (old_s2 != _newS2) {\n                RobotArm.Servo(RobotArm.Servos.S2, old_s2)\n                old_s2 = old_s2 + signS2;\n            }\n            if (old_s1 != _newS1) {\n                RobotArm.Servo(RobotArm.Servos.S1, old_s1)\n                old_s1 = old_s1 + signS1;\n            }\n            basic.pause(movement_delay);\n\n            // console.log(\"Servo s3 is:\");\n            // console.log(old_s3);\n            // console.log(\"Servo s2 is:\");\n            // console.log(old_s2);\n            // console.log(\"Servo s1 is:\");\n            // console.log(old_s1);\n        }\n        //old_s1 = _newS1;\n        //old_s2 = _newS2;\n        //old_s3 = _newS3;\n    }\n\n    let _myNewS3: number = old_s3;\n    let _myNewS2: number = old_s2;\n    let _myNewS1: number = old_s1;\n    let _stepS3: number = 0;\n    let _stepS2: number = 0;\n    let _stepS1: number = 0;\n\n    /**\n    * Manual Control of Robot Arm\n    */\n    //% blockId=manualControl block=\"Set |S1 = %_mS1| S2 = %_mS2| S3 = %_mS3\"\n    //% weight=110\n    export function manualMotion(_mS1: number, _mS2: number, _mS3: number): void {\n\n        _myNewS3 = old_s3 + _mS3;\n        _myNewS2 = old_s2 + _mS2;\n        _myNewS1 = old_s1 + _mS1;\n\n        _stepS3 = _mS3 / 10;\n        _stepS2 = _mS2 / 10;\n        _stepS1 = _mS1 / 10;\n\n        if (_myNewS3 > s3UpLimit) {\n            _myNewS3 = s3UpLimit;\n            old_s3 = _myNewS3;\n\n        } else if (_myNewS3 < s3LowLimit) {\n            _myNewS3 = s3LowLimit;\n            old_s3 = _myNewS3;\n        }\n        if (_myNewS2 > s2UpLimit) {\n            _myNewS2 = s2UpLimit;\n            old_s2 = _myNewS2;\n\n        } else if (_myNewS2 < s2LowLimit) {\n            _myNewS2 = s2LowLimit;\n            old_s2 = _myNewS2;\n        }\n        if (_myNewS1 > s1UpLimit) {\n            _myNewS1 = s1UpLimit;\n            old_s1 = _myNewS1;\n\n        } else if (_myNewS1 < s1LowLimit) {\n            _myNewS1 = s1LowLimit;\n            old_s1 = _myNewS1;\n        }\n\n\n        while ((old_s3 != _myNewS3) || (old_s2 != _myNewS2) || (old_s1 != _myNewS1)) {\n            if (old_s3 != _myNewS3) {\n                RobotArm.Servo(RobotArm.Servos.S3, old_s3)\n\n                old_s3 = old_s3 + _stepS3;\n\n                console.log(\"Servo s3 is:\");\n                console.log(old_s3);\n\n            }\n            if (old_s2 != _myNewS2) {\n                RobotArm.Servo(RobotArm.Servos.S2, old_s2)\n                old_s2 = old_s2 + _stepS2;\n                console.log(\"Servo s2 is:\");\n                console.log(old_s2);\n            }\n            if (old_s1 != _myNewS1) {\n                RobotArm.Servo(RobotArm.Servos.S1, old_s1)\n                old_s1 = old_s1 + _stepS1;\n                console.log(\"Servo s1 is:\");\n                console.log(old_s1);\n            }\n            basic.pause(10);\n\n        }\n        //old_s1 = _newS1;\n        //old_s2 = _newS2;\n        //old_s3 = _newS3;\n    }\n\n\n    //* Servo Motor *//\n\n    const PCA9685_ADDRESS = 0x40\n    const MODE1 = 0x00\n    const PRESCALE = 0xFE\n    const LED0_ON_L = 0x06\n\n    export enum Servos {\n        S1 = 0x01,\n        S2 = 0x02,\n        S3 = 0x03,\n        S4 = 0x04,\n        S5 = 0x05,\n        S6 = 0x06,\n        S7 = 0x07,\n        S8 = 0x08\n    }\n\n    let initialized = false\n\n    function i2cwrite(addr: number, reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2cread(addr: number, reg: number) {\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\n        return val;\n    }\n\n    function initPCA9685(): void {\n        i2cwrite(PCA9685_ADDRESS, MODE1, 0x00)\n        setFreq(50);\n        for (let idx = 0; idx < 16; idx++) {\n            setPwm(idx, 0, 0);\n        }\n        initialized = true\n    }\n\n    function setFreq(freq: number): void {\n        // Constrain the frequency\n        let prescaleval = 25000000;\n        prescaleval /= 4096;\n        prescaleval /= freq;\n        prescaleval -= 1;\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\n        let oldmode = i2cread(PCA9685_ADDRESS, MODE1);\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\n        i2cwrite(PCA9685_ADDRESS, MODE1, newmode); // go to sleep\n        i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);\n        control.waitMicros(5000);\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);\n    }\n\n    function setPwm(channel: number, on: number, off: number): void {\n        if (channel < 0 || channel > 15)\n            return;\n\n        let buf = pins.createBuffer(5);\n        buf[0] = LED0_ON_L + 4 * channel;\n        buf[1] = on & 0xff;\n        buf[2] = (on >> 8) & 0xff;\n        buf[3] = off & 0xff;\n        buf[4] = (off >> 8) & 0xff;\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf);\n    }\n\n    /**\n     * Servo Execute\n     * @param index Servo Channel; eg: S1\n     * @param degree [0-180] degree of servo; eg: 0, 90, 180\n    */\n    //% blockId=robotbit_servo block=\"Servo|%index|degree %degree\"\n    //% weight=40\n    //% color=\"#00aeef\"\n    //% degree.min=0 degree.max=180\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function Servo(index: Servos, degree: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        // 50hz: 20,000 us\n        let v_us = (degree * 1800 / 180 + 600) // 0.6 ~ 2.4\n        let value = v_us * 4096 / 20000\n        setPwm(index + 7, 0, value)\n    }\n\n    /* Joystick */\n\n    export enum JoystickBitPin {\n        //% block=\"B1\"\n        P13 = DAL.MICROBIT_ID_IO_P13,\n        //% block=\"B2\"\n        P14 = DAL.MICROBIT_ID_IO_P14,\n        //% block=\"B3\"\n        P15 = DAL.MICROBIT_ID_IO_P15,\n        //% block=\"B4\"\n        P16 = DAL.MICROBIT_ID_IO_P16\n    }\n\n    export enum rockerType {\n        //% block=\"X\"\n        X,\n        //% block=\"Y\"\n        Y\n    }\n\n    export enum ButtonType {\n        //% block=\"pressed\"\n        down = PulseValue.High,\n        //% block=\"released\"\n        up = PulseValue.Low\n    }\n\n    /**\n    * initialization joystick\n    */\n    export function initJoystick(): void {\n        pins.digitalWritePin(DigitalPin.P12, 0)\n        pins.setPull(DigitalPin.P13, PinPullMode.PullUp)\n        pins.setPull(DigitalPin.P14, PinPullMode.PullUp)\n        pins.setPull(DigitalPin.P15, PinPullMode.PullUp)\n        pins.setPull(DigitalPin.P16, PinPullMode.PullUp)\n        //pins.digitalWritePin(DigitalPin.P0, 1)\n    }\n\n    //% block=\"Initialize Joystick\"\n    //% weight=500\n    //% color=\"#E00064\"\n    export function init_joystick() {\n        initJoystick()\n    }\n\n    /**\n    * get Button\n    */\n    //% blockId=getButton block=\"button %button is pressed\"\n    //% color=\"#FFAA00\"\n    //% weight=29\n    export function getButton(button: JoystickBitPin): boolean {\n        return (pins.digitalReadPin(<number>button) == 0 ? true : false)\n    }\n\n    /**\n    * Registers code to run when a joystick event is detected.\n    */\n    //% blockId=onButtonEvent block=\"on button %button|is %event\" blockExternalInputs=false\n    //% color=\"#FFAA00\"\n    //% weight=28\n    export function onButtonEvent(button: JoystickBitPin, event: ButtonType, handler: Action): void {\n        pins.onPulsed(<number>button, <number>event, handler)"],[0,";\n    "],[1,"}\n\n"],[0,"    "],[-1,"result -= 273.15;\n\n        return result;"],[1,"/**\n    * get rocker value\n    * @param rocker describe parameter here, eg: 1\n    */\n    //% blockId=getRockerValue block=\"rocker value of %rocker\"\n    //% color=\"#FFAA00\"\n    //% weight=27\n    export function getRockerValue(rocker: rockerType): number {\n        switch (rocker) {\n            case rockerType.X: return pins.analogReadPin(AnalogPin.P2);\n            case rockerType.Y: return pins.analogReadPin(AnalogPin.P1);\n            default: return 0;\n        }\n    }\n\n    /**\n    * vibration motor\n    * @param time describe parameter here, eg: 100\n    */\n    //% blockId=Vibration_Motor block=\"motor vibrate for %time ms\"\n    //% color=\"#FFAA00\"\n    //% weight=26\n    export function Vibration_Motor(time: number): void {\n        pins.digitalWritePin(DigitalPin.P0, 0)\n        basic.pause(time)\n        pins.digitalWritePin(DigitalPin.P0, 1)"],[0,"\n    }\n"],[-1,"}"],[0,"\n"],[1,"}"]],"start1":114,"start2":114,"length1":449,"length2":16262}]}]},{"timestamp":1739271343793,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"RemoteHealthSensors.ts","patch":[{"diffs":[[0," 3, "],[-1,"fa"],[1,"true"],[0,");\n "]],"start1":403,"start2":403,"length1":10,"length2":12}]}]},{"timestamp":1739271347410,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"iables><"],[1,"block type=\"device_forever\" x=\"352\" y=\"108\"><statement name=\"HANDLER\"><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"RemoteHealthSensors_read_temperature\"></block></value></block></statement></block><"],[0,"/xml>"]],"start1":71,"start2":71,"length1":13,"length2":296}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"wNumber("],[1,"Remote"],[0,"HealthSe"]],"start1":41,"start2":41,"length1":16,"length2":22}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":276,"start2":276,"length1":52,"length2":8}]},{"type":"edited","filename":"RemoteHealthSensors.ts","patch":[{"diffs":[[0,"/**\n * "],[1,"Remote"],[0,"HealthSe"]],"start1":0,"start2":0,"length1":15,"length2":21},{"diffs":[[0,"\n * "],[-1,"Developed"],[1,"Written"],[0," by "]],"start1":39,"start2":39,"length1":17,"length2":15},{"diffs":[[0," VTC STE"],[-1,"A"],[0,"M Educat"]],"start1":53,"start2":53,"length1":17,"length2":16},{"diffs":[[0,"=\"\\u"],[-1,"2665"],[1,"f1ec"],[0,"\" bl"]],"start1":108,"start2":108,"length1":12,"length2":12},{"diffs":[[0," block=\""],[1,"Remote"],[0,"HealthSe"]],"start1":117,"start2":117,"length1":16,"length2":22},{"diffs":[[0,"mespace "],[1,"Remote"],[0,"HealthSe"]],"start1":148,"start2":148,"length1":16,"length2":22},{"diffs":[[0,", fa"],[-1,"lse"],[0,");\n "]],"start1":405,"start2":405,"length1":11,"length2":8},{"diffs":[[0," buff[0]"],[1," << 8"],[0,";\n      "]],"start1":432,"start2":432,"length1":16,"length2":21},{"diffs":[[0," buff[1]"],[-1," << 8"],[0,";\n      "]],"start1":464,"start2":464,"length1":21,"length2":16}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1739270074436,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"Test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1739271749665}